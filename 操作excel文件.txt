使用openpyxl模块

一、官方文档
	（一）地址：http://openpyxl.readthedocs.io/en/stable/
		1.操作workbook
			（1）创建workbook
				使用openpyxl模块时无需创建excel文件，直接导入Workbook类开始使用
					>>> from openpyxl import Workbook
					>>> wb = Workbook()
				一个workbook总是创建至少一个worksheet，也可以这样用
					openpyxl.workbook.Workbook.active()
				ws = wb.active：这个函数使用的是_active_sheet_index属性，默认为0，不修改这个值时总是得到第一个worksheet。
				也可以使用openpyxl.workbook.Workbook.create_sheet()方法创建新worksheet：
					>>> ws1 = wb.create_sheet("Mysheet") # insert at the end (default)	默认在最后插入
					# or
					>>> ws2 = wb.create_sheet("Mysheet", 0) # insert at first position	在第一个位置插入
				表单创建时会自动给一个名字，按顺序：Sheet1, Sheet2, Sheet3, ...，也可以在任何时间用title属性进行更改：
					ws.title = "New Title"
				默认工作表标签背景颜色时白色，可以用RRGGBB颜色代码设置sheet_properties.tabColor属性：
					ws.sheet_properties.tabColor = "1072BA"
				一旦给表单指定一个名字，可以将其作为key从workbook中获取
				可以检视所有worksheet名字使用openpyxl.workbook.Workbook.sheetnames()属性。
					print(wb.sheetnames)
				也可以通过循环来获取：
					for sheet in wb:
						print(sheet.title)
				可以使用openpyxl.workbook.Workbook.copy_worksheet()方法来创建worksheet副本：
					# 仅单元（包括值、样式、超链接、注释）和特定的worksheet属性（包括大小、版式、和属性）被复制，其他的workbook/worksheet属性不会被复制，如：图像、图表
					# 不能跨worksheet复制，也不能复制read-only或write-only模式下的worksheet
					source = wb .active
					target = wb.copy_worksheet(source)
		2.数据操作
			（1）进入单元格
				单元格可以直接通过工作表的关键字来进入
					c = ws['A4']
				返回A4位置的单元格，如果不存在的话创建一个，数值可以直接指派：
					ws['A4] = 4
				同样也由openpyxl.worksheet.Worksheet.cell()来实现，可以通过使用行和列注释类进入单元格：
					# 当一个worksheet工作表在内存里创建，它是不包含单元格的，仅当第一次进入是会被创建
					d = ws.cell(row=4, column=2, value=10)
				警告：
					因为这个特征，即使你不给他们指派一个值，浏览单元格也会在内存中创建单元格。例如：
							# 这段代码会在内存里创建100*100的空单元格
						>>> for i in range(1,101):
						...        for j in range(1,101):
						...            ws.cell(row=i, column=j)
			（2）进入多个单元格
				范围性的单元格可以由切片进入：
					cell_range = ws['A1':'C2']
				同样的，多行或多列也可通过类似方式取得：
					# C列
					cloC = ws['C']
					# C列、D列
					col_range = ws['C:D']
					# 第10行
					row10 = ws[10]
					# 第5-10行
					row_range = ws[5:10]
				当然也可以用openpyxl.worksheet.Worksheet.iter_rows()或者openpyxl.worksheet.Worksheet.iter_cols()来获取：
					# 最小行为1，最大列为3，最大行为2，结果为A1 B1 C1 A2 B2 C2
					for row in ws.iter_rows(min_row=1, max_col=3, max_row=2):
						for cell in row :
							print(cell)
					# 最小行为1，最大列为3，最大行为2，结果为A1 A2 B1 B2 C1 C2,注意同上面的结果进行区分
					for col in ws.iter_cols(min_row=1, max_col=3, max_row=2):
						for cell in col:
							print(cell)
				如果需要遍历所有行或列，可以用openpyxl.worksheet.Worksheet.rows()或openpyxl.worksheet.Worksheet.columns()
			（3）数据存储
				一旦得到了openpyxl.cell.Cell对象，我们就可以给它指定一个数值：
					c.value = 'Hello, World'
					print(c.value)
				？？？也可启用类型和格式推断
					# ???guess_types???
					>>> wb = Workbook(guess_types=True)
					>>> c.value = '12%'
					>>> print(c.value)
					0.12

					>>> import datetime
					>>> d.value = datetime.datetime.now()
					>>> print d.value
					datetime.datetime(2010, 9, 10, 22, 25, 18)

					>>> c.value = '31.50'
					>>> print(c.value)
					31.5
			（4）保存文件
				最简单安全的方式是使用 openpyxl.workbook.Workbook.save()方法：
					wb = Workbook()
					wb.save('balances.xlsx')
				！警告：
					这个操作会覆盖现有文件并且不会由任何提示。
				扩展名可以不是xlsx或xlsm，尽管你可能在打开的时候有些麻烦。因为OOXML文件是基于ZIP文件的，你可以一.zip作为扩展名并且用解压软件来打开。
				可以指定template=True来将其保存为模板：
					wb = load_workbook('document.xlsx')
					wb.template = True
					wb.save('document_template.xltx')
				或者设置为False（默认）,保存成文档：
					wb = load_workbook('document_template.xltx')
					wb.template = False
					wb.save('document.xlsx', as_template=False)
				！警告：
					你应该管理号自己的数据属性和文档扩展名，否则会出现用桌面软件无法打开的情况。下面这几种情况就会出错：
						>>> wb = load_workbook('document.xlsx')
						>>> # Need to save with the extension *.xlsx	需保存为.xlsx为扩展名
						>>> wb.save('new_document.xlsm')
						>>> # MS Excel can't open the document	微软Excel程序不能打开这个文档
						>>>
						>>> # or
						>>>
						>>> # Need specify attribute keep_vba=True	需指定keep_vba=True
						>>> wb = load_workbook('document.xlsm')
						>>> wb.save('new_document.xlsm')
						>>> # MS Excel will not open the document	微软Excel程序不能打开这个文档
						>>>
						>>> # or
						>>>
						>>> wb = load_workbook('document.xltm', keep_vba=True)
						>>> # If we need a template document, then we must specify extension as *.xltm.	如果需要一个模板文档，指定扩展名为xltm
						>>> wb.save('new_document.xlsm')
						>>> # MS Excel will not open the document
			（5）加载文件
				与写类似，可以导入openpyxl.load_workbook()来打开现有工作簿workbook:
					>>> from openpyxl import load_workbook
					>>> wb2 = load_workbook('test.xlsx')
					>>> print wb2.get_sheet_names()
					['Sheet2', 'New Title', 'Sheet1']
		3.简单应用
			（1）写工作簿
				from openpyxl import Workbook
				from openpyxl.utils import get_column_letter
				# 创建workbook
				wb = Workbook()
				# 文件名
				dest_filename = 'empty_book.xlsx'
				# 获取第一个活动工作表，设置表单名
				ws1 = wb.active
				ws1.title = "range names"
				# 1-40行添加0-600数字
				for row in range(1, 40):
					ws1.append(range(600))
				# 创建第二个表单名字为Pi
				ws2 = wb.create_sheet(title="Pi")
				# 将F5单元格设置为3.14
				ws2['F5'] = 3.14
				# 创建第三个表单名字为Data，用列名填充第10-20行
				ws3 = wb.create_sheet(title="Data")
				for row in range(10, 20):
					for col in range(27, 54):
						ws3.cell(column=col, row=row, value="{0}".format(get_column_letter(col)))
				print(ws3['AA10'].value)
				# 保存文件
				wb.save(filename=dest_filename)
			（2）读工作簿
				from openpyxl import load_workbook
				# 加载指定文件名的工作簿
				wb = load_workbook(filename='empty_book.xlsx')
				# 获取指定名字的表单
				sheet_ranges = wb['range names']
				# 打印指定单元格内容
				print(sheet_ranges['D18'].value)
				注意：
					有几个标志位可以在load_workbook时使用：
						guess_types 可以启用或禁用（默认）读单元格时的类型推断。
						data_only 控制了有单元格里的内容是公式（默认）还是数据。
						keep_vba 控制VB元素保存还是不保存（默认），即使保存也是不可编辑的。
				！警告：
					openpyxl现阶段并不能获取所有Excel文件的内容，图片和图表如果打开保存为同一名字时会丢失。
			（3）使用数字格式化
				import datetime
				from openpyxl import Workbook
				wb = Workbook()
				ws = wb.active
				# set date using a Python datetime  设置日期使用Python datetime
				ws['A1'] = datetime.datetime(2010, 7, 21)
				print('Python datetime format: ' + ws['A1'].number_format)
				# You can enable type inference on a case-by-case basis 也可启用类型推定
				wb.guess_types = True
				# set percentage using a string followed by the percent sign    使用百分数后面跟百分号
				ws['B1'] = '3.14%'
				wb.guess_types = False
				print('This percentage is: ' + str(ws['B1'].value))
				print('Percentage type inference is: ' + ws['B1'].number_format)
			（4）使用公式
				from openpyxl import Workbook
				wb = Workbook()
				ws = wb.active
				# add a simple formula
				ws["A1"] = "=SUM(1, 1)"
				wb.save("formula.xlsx")
				！警告
					函数必须使用英文名，函数参数必须使用逗号分隔。
				openpyxl不评估一个公式，但可以检验是不是公式：
					>>> from openpyxl.utils import FORMULAE
					>>> "HEX2DEC" in FORMULAE
					True
				如果你尝试使用一个公式但是不识别，可能是因为你用的公式不包含在初始规范内，这样的公式必须加前缀：_xlfn.才可以工作。
			（5）合并、拆分单元格
				from openpyxl.workbook import Workbook

				wb = Workbook()
				ws = wb.active

				# 合并A2:D2单元格
				ws.merge_cells('A2:D2')
				# ws.unmerge_cells('A2:D2')

				# or equivalently   等价于
				# ws.merge_cells(start_row=2, start_column=1, end_row=4, end_column=4)
				# ws.unmerge_cells(start_row=2, start_column=1, end_row=4, end_column=4)

				wb.save('merge_book.xlsx')
			（6）插入图像
				from openpyxl import Workbook
				from openpyxl.drawing.image import Image

				wb = Workbook()
				ws = wb.active
				ws['A1'] = 'You should see image below'

				# create an image   创建图片
				img = Image('logo.png')

				# B5是添加的左上角位置
				ws.add_image(img, 'B5')
				wb.save('image_book.xlsx')
			（7）折叠列
				import openpyxl
				wb = openpyxl.Workbook()
				ws = wb.active
				# 折叠第A—D列
				ws.column_dimensions.group('A', 'D', hidden=True)
				wb.save('group.xlsx')
		4.同Pandas以及NumPy一起使用
			（1）NumPy支持
				openpyxl内建了对NumPy类型的浮点、整数以及布尔数的支持,DateTimes类型也可通过Pandas’ Timestamp类型予以支持。
			（2）Pandas Dataframes
				openpyxl.utils.dataframe.dataframe_to_rows()函数提供了与Pandas Dataframes一起使用的简单方法：
					from openpyxl.utils.dataframe import dataframe_to_rows
					from openpyxl import Workbook
					from pandas import DataFrame

					wb = Workbook()
					ws = wb.active
					# 左侧是索引abc，上面是行xyz，中间是数据123,456,789
					# index为True时包含左侧索引，columns为True时包含上面行名称
					df = DataFrame([[1,2,3], [4,5,6], [7,8,9]], index=['a', 'b', 'c'], columns=['x','y','z'])
					for r in dataframe_to_rows(df, index=True, header=True):
						ws.append(r)
					wb.save('pandas_book.xlsx')
				Pandas自身提供了转换到Excel的方法，这为客户端代码提供了额外的灵活性，包括将数据流直接流到文件的能力。
				将数据文件转换为工作表，并且突出显示头和索引：
					from openpyxl.utils.dataframe import dataframe_to_rows
					from openpyxl import Workbook
					from pandas import DataFrame

					wb = Workbook()
					ws = wb.active
					# 左侧是索引abc，上面是行xyz，中间是数据123,456,789
					# index为True时包含左侧索引，columns为True时包含上面行名称
					df = DataFrame([[1,2,3], [4,5,6], [7,8,9]], index=['a', 'b', 'c'], columns=['x','y','z'])
					for r in dataframe_to_rows(df, index=True, header=True):
						ws.append(r)

					for cell in ws['A'] + ws[1]:
						# 设置单元格样式为Pandas
						cell.style = 'Pandas'

					wb.save("pandas_openpyxl.xlsx")
				如果只想转换数据，可以使用只写模式：
					from openpyxl.cell.cell import WriteOnlyCell
					from openpyxl import Workbook
					from pandas import DataFrame
					from openpyxl.utils.dataframe import dataframe_to_rows

					wb = Workbook(write_only=True)
					ws = wb.create_sheet()

					cell = WriteOnlyCell(ws)
					cell.style = 'Pandas'

					def format_first_row(row, cell):
						for c in row:
							cell.value = c
							yield cell

					df = DataFrame([[1,2,3], [4,5,6], [7,8,9]], index=['a', 'b', 'c'], columns=['x','y','z'])
					rows = dataframe_to_rows(df)
					first_row = format_first_row(next(rows), cell)
					ws.append(first_row)

					for row in rows:
						row = list(row)
						cell.value = row[0]
						row[0] = cell
						ws.append(row)

					wb.save("openpyxl_stream.xlsx")
			（3）将工作表转换为数据文件
				若要将工作表转换为数据文件DataFrame，可以使用value属性。
					df = DataFrame(ws.values)
				如果工作表确实有标题或索引，比如使用Pandas创建的，那么就需要做略多的工作：
					data = ws.values
					cols = next(data)[1:]
					data = list(data)
					idx = [r[0] for r in data]
					data = (islice(r, 1, None) for r in data)
					df = DataFrame(data, index=idx, columns=cols)
		5.图表Charts
			（1）种类
				A）Area Charts	面积图
					A1）2D Area Charts 2D面积图
						面积图与线图相类似，是将线图下面区域填充形成的，通过将分组设置为standard、stacked、percentStacked，可以获得不同的变体，其中standard为默认值。
							from openpyxl import Workbook
							from openpyxl.chart import (
								AreaChart,
								Reference,
							)

							wb = Workbook()
							ws = wb.active

							rows = [
								['Number', 'Batch 1', 'Batch 2'],
								[2, 40, 30],
								[3, 40, 25],
								[4, 50, 30],
								[5, 30, 10],
								[6, 25, 5],
								[7, 50, 10],
							]

							for row in rows:
								ws.append(row)

							chart = AreaChart()
							chart.title = 'Area Chart'
							# style可以时1-48
							chart.style = 1
							chart.x_axis.title = "Test"
							chart.y_axis.title = "Percentage"

							# ata就是面积图的点，第2、3列2-7行的数字,但是图例会从第一组数据中提取，因此应该是1-7行
							cat = Reference(ws, min_col=1, min_row=2, max_row =7)
							# data就是面积图的点，第2、3列2-7行的数字
							datas = Reference(ws, min_col=2, max_col=3, min_row=2, max_row=7)
							chart.add_data(datas, titles_from_data=True)
							chart.set_categories(cat)

							ws.add_chart(chart, "A10")
							wb.save("area.xlsx")
					A2）3D Area Charts 3D面积图
						还可以创建3D面积图
							from openpyxl import Workbook
							from openpyxl.chart import (
								AreaChart3D,
								Reference,
							)

							wb = Workbook()
							ws = wb.active

							rows = [
								['Number', 'Batch 1', 'Batch 2'],
								[2, 30, 40],
								[3, 25, 40],
								[4 ,30, 50],
								[5 ,10, 30],
								[6,  5, 25],
								[7 ,10, 50],
							]

							for row in rows:
								ws.append(row)

							chart = AreaChart3D()
							chart.title = "Area Chart"
							chart.style = 13
							chart.x_axis.title = 'Test'
							chart.y_axis.title = 'Percentage'
							chart.legend = None

							cats = Reference(ws, min_col=1, min_row=1, max_row=7)
							data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=7)
							chart.add_data(data, titles_from_data=True)
							chart.set_categories(cats)

							ws.add_chart(chart, "A10")

							wb.save("area3D.xlsx")
				B）Bar and Column Charts	条形图和柱状图
					B1)Vertical, Horizontal and Stacked Bar Charts	垂直、水平和堆积条形图
						注意：将type设置为col或bar显示不同效果，当使用堆积图时overlap属性需要设置为100，如果为水平图，xy轴是相反的。
							from openpyxl import Workbook
							from openpyxl.chart import BarChart, Reference
							from copy import deepcopy

							wb = Workbook()
							ws = wb.active

							rows = [
								('Number', 'Batch 1', 'Batch 2'),
								(2, 10, 30),
								(3, 40, 60),
								(4, 50, 70),
								(5, 20, 10),
								(6, 10, 40),
								(7, 50, 30),
							]

							for row in rows:
								ws.append(row)

							bar_chart = BarChart()
							bar_chart.type = 'col'
							bar_chart.style = 14
							bar_chart.title = "Bar Chart"
							bar_chart.x_axis.title = "Test number"
							bar_chart.y_axis.title = "Sample length(mm)"

							data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=7)
							cat = Reference(ws, min_col=1, min_row=2, max_row=7)
							bar_chart.add_data(data, titles_from_data=True)
							bar_chart.set_categories(cat)
							ws.add_chart(bar_chart, "A10")

							hor_bar_chart = deepcopy(bar_chart)
							hor_bar_chart.type = 'bar'
							hor_bar_chart.title = "Horizontal Bar Chart"
							ws.add_chart(hor_bar_chart, 'J10')

							col_chart = deepcopy(bar_chart)
							col_chart.type = 'col'
							col_chart.grouping = 'stacked'
							# Chart的overlap（重叠）属性必须设置为100，否则显示效果不好
							col_chart.overlap = 100
							col_chart.title = 'Stacked Chart'
							ws.add_chart(col_chart, 'A25')

							hor_col_chart = deepcopy(bar_chart)
							hor_col_chart.type = 'bar'
							hor_col_chart.grouping = 'stacked'
							hor_col_chart.overlap = 100
							hor_col_chart.title = 'Horizontal Stacked Chart'
							ws.add_chart(hor_col_chart, 'J25')

							wb.save("bar_stacked_chart.xlsx")
					B2）3D Bar Chart 3D条形图
						from openpyxl import Workbook
						from openpyxl.chart import (
							Reference,
							Series,
							BarChart3D,
						)

						wb = Workbook()
						ws = wb.active

						rows = [
							(None, 2013, 2014),
							("Apples", 5, 4),
							("Oranges", 6, 2),
							("Pears", 8, 3)
						]

						for row in rows:
							ws.append(row)

						data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=4)
						titles = Reference(ws, min_col=1, min_row=2, max_row=4)
						chart = BarChart3D()
						chart.title = "3D Bar Chart"
						chart.add_data(data=data, titles_from_data=True)
						chart.set_categories(titles)

						ws.add_chart(chart, "E5")
						wb.save("bar3d.xlsx")
				C）Bubble Charts	气泡图
					气泡图类似于散点图，但使用第三维来确定气泡的大小。图表可以包括多个系列。
						from openpyxl import Workbook
						from openpyxl.chart import Series, Reference, BubbleChart

						wb = Workbook()
						ws = wb.active

						rows = [
							("Number of Products", "Sales in USD", "Market share"),
							(14, 12200, 15),
							(20, 60000, 33),
							(18, 24400, 10),
							(22, 32000, 42),
							(),
							(12, 8200, 18),
							(15, 50000, 30),
							(19, 22400, 15),
							(25, 25000, 50),
						]

						for row in rows:
							ws.append(row)

						chart = BubbleChart()
						chart.style = 42 # use a preset style

						# add the first series of data  添加第1个系列的数据
						# X轴用第1列数据
						xvalues = Reference(ws, min_col=1, min_row=2, max_row=5)
						# Y轴用第2列数据
						yvalues = Reference(ws, min_col=2, min_row=2, max_row=5)
						# 气泡大小用第3列数据
						size = Reference(ws, min_col=3, min_row=2, max_row=5)
						series = Series(values=yvalues, xvalues=xvalues, zvalues=size, title="2013")
						chart.series.append(series)

						# add the second    添加第2个系列的数据
						xvalues = Reference(ws, min_col=1, min_row=7, max_row=10)
						yvalues = Reference(ws, min_col=2, min_row=7, max_row=10)
						size = Reference(ws, min_col=3, min_row=7, max_row=10)
						series = Series(values=yvalues, xvalues=xvalues, zvalues=size, title="2014")
						chart.series.append(series)

						# place the chart starting in cell E1
						ws.add_chart(chart, "E1")
						wb.save("bubble.xlsx")
				D）Line Charts	折线图
					D1）折线图
						线图允许数据对固定轴绘制。它们与散点图相似，主要区别在于，用线图对每个数据序列绘制相同的值。副轴可以使用不同种类的轴。
						与条形图相似，有三种线形图：standard, stacked 和percentStacked。
							from datetime import date

							from openpyxl import Workbook
							from openpyxl.chart import (
								LineChart,
								Reference,
							)
							from openpyxl.chart.axis import DateAxis

							wb = Workbook()
							ws = wb.active

							rows = [
								['Date', 'Batch 1', 'Batch 2', 'Batch 3'],
								[date(2015,9, 1), 40, 30, 25],
								[date(2015,9, 2), 40, 25, 30],
								[date(2015,9, 3), 50, 30, 45],
								[date(2015,9, 4), 30, 25, 40],
								[date(2015,9, 5), 25, 35, 30],
								[date(2015,9, 6), 20, 40, 35],
							]

							for row in rows:
								ws.append(row)

							c1 = LineChart()
							c1.title = "Line Chart"
							c1.style = 40
							c1.y_axis.title = 'Size'
							c1.x_axis.title = 'Test Number'

							data = Reference(ws, min_col=2, min_row=1, max_col=4, max_row=7)
							c1.add_data(data, titles_from_data=True)

							# Style the lines
							s1 = c1.series[0]
							# 标志符号设置为三角
							s1.marker.symbol = "triangle"
							# 填充红色
							s1.marker.graphicalProperties.solidFill = "FF0000" # Marker filling
							# 线轮廓红色
							s1.marker.graphicalProperties.line.solidFill = "FF00FF" # Marker outline

							s1.graphicalProperties.line.noFill = True

							s2 = c1.series[1]
							s2.graphicalProperties.line.solidFill = "00AAAA"
							s2.graphicalProperties.line.dashStyle = "sysDot"
							s2.graphicalProperties.line.width = 100050 # width in EMUs

							s2 = c1.series[2]
							s2.smooth = True # Make the line smooth

							ws.add_chart(c1, "A10")

							from copy import deepcopy
							stacked = deepcopy(c1)
							stacked.grouping = "stacked"
							stacked.title = "Stacked Line Chart"
							ws.add_chart(stacked, "A27")

							percent_stacked = deepcopy(c1)
							percent_stacked.grouping = "percentStacked"
							percent_stacked.title = "Percent Stacked Line Chart"
							ws.add_chart(percent_stacked, "A44")

							# Chart with date axis
							c2 = LineChart()
							c2.title = "Date Axis"
							c2.style = 12
							c2.y_axis.title = "Size"
							c2.y_axis.crossAx = 500
							c2.x_axis = DateAxis(crossAx=100)
							c2.x_axis.number_format = 'd-mmm'
							c2.x_axis.majorTimeUnit = "days"
							c2.x_axis.title = "Date"

							c2.add_data(data, titles_from_data=True)
							dates = Reference(ws, min_col=1, min_row=2, max_row=7)
							c2.set_categories(dates)

							ws.add_chart(c2, "A61")

							wb.save("line.xlsx")
					D2）3D折线图
						from datetime import date

						from openpyxl import Workbook
						from openpyxl.chart import (
							LineChart3D,
							Reference,
						)
						from openpyxl.chart.axis import DateAxis

						wb = Workbook()
						ws = wb.active

						rows = [
							['Date', 'Batch 1', 'Batch 2', 'Batch 3'],
							[date(2015,9, 1), 40, 30, 25],
							[date(2015,9, 2), 40, 25, 30],
							[date(2015,9, 3), 50, 30, 45],
							[date(2015,9, 4), 30, 25, 40],
							[date(2015,9, 5), 25, 35, 30],
							[date(2015,9, 6), 20, 40, 35],
						]

						for row in rows:
							ws.append(row)

						c1 = LineChart3D()
						c1.title = "3D Line Chart"
						c1.legend = None
						c1.style = 15
						c1.y_axis.title = 'Size'
						c1.x_axis.title = 'Test Number'

						data = Reference(ws, min_col=2, min_row=1, max_col=4, max_row=7)
						c1.add_data(data, titles_from_data=True)

						ws.add_chart(c1, "A10")

						wb.save("line3D.xlsx")
				E）Scatter Charts	散点图
					散点图类似于一些线图，主要的区别是一系列的值被绘制为另一个值。这是有用的，因为值是无序的。
						from openpyxl import Workbook
						from openpyxl.chart import (
							ScatterChart,
							Reference,
							Series,
						)

						wb = Workbook()
						ws = wb.active

						rows = [
							['Size', 'Batch 1', 'Batch 2'],
							[2, 40, 30],
							[3, 40, 25],
							[4, 50, 30],
							[5, 30, 25],
							[6, 25, 35],
							[7, 20, 40],
						]

						for row in rows:
							ws.append(row)

						chart = ScatterChart()
						chart.title = "Scatter Chart"
						chart.style = 13
						chart.x_axis.title = 'Size'
						chart.y_axis.title = 'Percentage'

						xvalues = Reference(ws, min_col=1, min_row=2, max_row=7)

						values_1 = Reference(ws, min_col=2, min_row=1, max_row=7)
						series_1 = Series(values_1, xvalues, title_from_data=True)
						chart.series.append(series_1)

						values_2 = Reference(ws, min_col=3, min_row=1, max_row=7)
						series_2 = Series(values_2, xvalues, title_from_data=True)
						chart.series.append(series_2)

						ws.add_chart(chart, "A10")

						wb.save("scatter.xlsx")
				F）Pie Charts	饼图
					F1）饼图
						饼图将数据绘制成圆的切片，每个切片表示整个百分比。切片是顺时针方向从圆的顶部0°位置开始绘制。饼图只能获取一系列数据。图表的标题将默认为该系列的标题。
							from openpyxl import Workbook

							from openpyxl.chart import (
								PieChart,
								ProjectedPieChart,
								Reference
							)
							from openpyxl.chart.series import DataPoint

							data = [
								['Pie', 'Sold'],
								['Apple', 50],
								['Cherry', 30],
								['Pumpkin', 10],
								['Chocolate', 40],
							]

							wb = Workbook()
							ws = wb.active

							for row in data:
								ws.append(row)

							pie = PieChart()
							labels = Reference(ws, min_col=1, min_row=2, max_row=5)
							data = Reference(ws, min_col=2, min_row=1, max_row=5)
							pie.add_data(data, titles_from_data=True)
							pie.set_categories(labels)
							pie.title = "Pies sold by category"

							# Cut the first slice out of the pie
							slice = DataPoint(idx=0, explosion=20)
							pie.series[0].data_points = [slice]

							ws.add_chart(pie, "D1")


							ws = wb.create_sheet(title="Projection")

							data = [
								['Page', 'Views'],
								['Search', 95],
								['Products', 4],
								['Offers', 0.5],
								['Sales', 0.5],
							]

							for row in data:
								ws.append(row)

							projected_pie = ProjectedPieChart()
							projected_pie.type = "pie"
							projected_pie.splitType = "val" # split by value
							labels = Reference(ws, min_col=1, min_row=2, max_row=5)
							data = Reference(ws, min_col=2, min_row=1, max_row=5)
							projected_pie.add_data(data, titles_from_data=True)
							projected_pie.set_categories(labels)

							ws.add_chart(projected_pie, "A10")

							from copy import deepcopy
							projected_bar = deepcopy(projected_pie)
							projected_bar.type = "bar"
							projected_bar.splitType = 'pos' # split by position

							ws.add_chart(projected_bar, "A27")

							wb.save("pie.xlsx")
					F2）投影饼图
						投影饼图从饼图中提取一些切片，并将它们投影到第二饼图或条形图中。当数据系列中有几个较小的条目时，这是有用的。该图表可以按百分比、val（ue）或pos（ition）划分。如果没有设置，则应用程序决定使用哪一个。此外，可以自定义自定义分割。
					F3）3D饼图
						from openpyxl import Workbook

						from openpyxl.chart import (
							PieChart3D,
							Reference
						)

						data = [
							['Pie', 'Sold'],
							['Apple', 50],
							['Cherry', 30],
							['Pumpkin', 10],
							['Chocolate', 40],
						]

						wb = Workbook()
						ws = wb.active

						for row in data:
							ws.append(row)

						pie = PieChart3D()
						labels = Reference(ws, min_col=1, min_row=2, max_row=5)
						data = Reference(ws, min_col=2, min_row=1, max_row=5)
						pie.add_data(data, titles_from_data=True)
						pie.set_categories(labels)
						pie.title = "Pies sold by category"


						ws.add_chart(pie, "D1")

						wb.save("pie3D.xlsx")
				G）Doughnut Charts	环形图
					环形图表类似于饼图，除了它们使用一个环而不是一个圆，还可以绘制几个系列的数据同心环。
						from openpyxl import Workbook

						from openpyxl.chart import (
							DoughnutChart,
							Reference,
							Series,
						)
						from openpyxl.chart.series import DataPoint

						data = [
							['Pie', 2014, 2015],
							['Plain', 40, 50],
							['Jam', 2, 10],
							['Lime', 20, 30],
							['Chocolate', 30, 40],
						]

						wb = Workbook()
						ws = wb.active

						for row in data:
							ws.append(row)

						chart = DoughnutChart()
						labels = Reference(ws, min_col=1, min_row=2, max_row=5)
						data = Reference(ws, min_col=2, min_row=1, max_row=5)
						chart.add_data(data, titles_from_data=True)
						chart.set_categories(labels)
						chart.title = "Doughnuts sold by category"
						chart.style = 26

						# Cut the first slice out of the doughnut
						slices = [DataPoint(idx=i) for i in range(4)]
						plain, jam, lime, chocolate = slices
						chart.series[0].data_points = slices
						plain.graphicalProperties.solidFill = "FAE1D0"
						jam.graphicalProperties.solidFill = "BB2244"
						lime.graphicalProperties.solidFill = "22DD22"
						chocolate.graphicalProperties.solidFill = "61210B"
						chocolate.explosion = 10

						ws.add_chart(chart, "E1")

						from copy import deepcopy

						chart2 = deepcopy(chart)
						chart2.title = None
						data = Reference(ws, min_col=3, min_row=1, max_row=5)
						series2 = Series(data, title_from_data=True)
						series2.data_points = slices
						chart2.series.append(series2)

						ws.add_chart(chart2, "E17")

						wb.save("doughnut.xlsx")
				H）Radar Charts	雷达图
					工作表中的列或行中排列的数据可以绘制在雷达图中。雷达图比较多个数据序列的总值。它实际上是圆形X轴上的面积图的投影
					雷达图有两种类型：standard，其中区域用直线标示，并填充整个区域填充的地方。附加类型“marker”没有效果。如果需要标记，可以为相关系列设置这些标记。
						from openpyxl import Workbook
						from openpyxl.chart import (
							RadarChart,
							Reference,
						)

						wb = Workbook()
						ws = wb.active

						rows = [
							['Month', "Bulbs", "Seeds", "Flowers", "Trees & shrubs"],
							['Jan', 0, 2500, 500, 0,],
							['Feb', 0, 5500, 750, 1500],
							['Mar', 0, 9000, 1500, 2500],
							['Apr', 0, 6500, 2000, 4000],
							['May', 0, 3500, 5500, 3500],
							['Jun', 0, 0, 7500, 1500],
							['Jul', 0, 0, 8500, 800],
							['Aug', 1500, 0, 7000, 550],
							['Sep', 5000, 0, 3500, 2500],
							['Oct', 8500, 0, 2500, 6000],
							['Nov', 3500, 0, 500, 5500],
							['Dec', 500, 0, 100, 3000 ],
						]

						for row in rows:
							ws.append(row)

						chart = RadarChart()
						chart.type = "filled"
						labels = Reference(ws, min_col=1, min_row=2, max_row=13)
						data = Reference(ws, min_col=2, max_col=5, min_row=1, max_row=13)
						chart.add_data(data, titles_from_data=True)
						chart.set_categories(labels)
						chart.style = 26
						chart.title = "Garden Centre Sales"
						chart.y_axis.delete = True

						ws.add_chart(chart, "A17")

						wb.save("radar.xlsx")
				I）Stock Charts	股票图
					在工作表中以特定顺序排列的列或行中的数据可以在股票图表中绘制。顾名思义，股票图表是用来说明股票价格波动的最常用的图表。然而，这张图表也可以用于科学数据。例如，你可以使用股票图表来指示每日或年度温度的波动。您必须按照正确的顺序组织数据以创建股票图表。
					在工作表中组织库存图表数据是非常重要的。例如，为了创建一个简单的高、低收盘股票图表，您应该以高、低、关的顺序排列您的数据，进入标题。
					虽然股票图表是一种不同的类型，但各种类型只是特定格式化选项的捷径：
					高低闭合本质上是一个没有线的线图，标记设置为XYZ。它也使hiLoLines设置为True。打开高低点关闭是一个高低收盘图表与标记的每个数据点设置为XZZ和上行线。
					可以通过将股票图表与条形图相结合来增加卷的体积。
					from datetime import date

					from openpyxl import Workbook

					from openpyxl.chart import (
						BarChart,
						StockChart,
						Reference,
						Series,
					)
					from openpyxl.chart.axis import DateAxis, ChartLines
					from openpyxl.chart.updown_bars import UpDownBars

					wb = Workbook()
					ws = wb.active

					rows = [
					   ['Date',      'Volume','Open', 'High', 'Low', 'Close'],
					   ['2015-01-01', 20000,    26.2, 27.20, 23.49, 25.45,  ],
					   ['2015-01-02', 10000,    25.45, 25.03, 19.55, 23.05, ],
					   ['2015-01-03', 15000,    23.05, 24.46, 20.03, 22.42, ],
					   ['2015-01-04', 2000,     22.42, 23.97, 20.07, 21.90, ],
					   ['2015-01-05', 12000,    21.9, 23.65, 19.50, 21.51,  ],
					]

					for row in rows:
						ws.append(row)

					# High-low-close
					c1 = StockChart()
					labels = Reference(ws, min_col=1, min_row=2, max_row=6)
					data = Reference(ws, min_col=4, max_col=6, min_row=1, max_row=6)
					c1.add_data(data, titles_from_data=True)
					c1.set_categories(labels)
					for s in c1.series:
						s.graphicalProperties.line.noFill = True
					# marker for close
					s.marker.symbol = "dot"
					s.marker.size = 5
					c1.title = "High-low-close"
					c1.hiLowLines = ChartLines()

					# Excel is broken and needs a cache of values in order to display hiLoLines :-/
					from openpyxl.chart.data_source import NumData, NumVal
					pts = [NumVal(idx=i) for i in range(len(data) - 1)]
					cache = NumData(pt=pts)
					c1.series[-1].val.numRef.numCache = cache

					ws.add_chart(c1, "A10")

					# Open-high-low-close
					c2 = StockChart()
					data = Reference(ws, min_col=3, max_col=6, min_row=1, max_row=6)
					c2.add_data(data, titles_from_data=True)
					c2.set_categories(labels)
					for s in c2.series:
						s.graphicalProperties.line.noFill = True
					c2.hiLowLines = ChartLines()
					c2.upDownBars = UpDownBars()
					c2.title = "Open-high-low-close"

					# add dummy cache
					c2.series[-1].val.numRef.numCache = cache

					ws.add_chart(c2, "G10")

					# Create bar chart for volume

					bar = BarChart()
					data =  Reference(ws, min_col=2, min_row=1, max_row=6)
					bar.add_data(data, titles_from_data=True)
					bar.set_categories(labels)

					from copy import deepcopy

					# Volume-high-low-close
					b1 = deepcopy(bar)
					c3 = deepcopy(c1)
					c3.y_axis.majorGridlines = None
					c3.y_axis.title = "Price"
					b1.y_axis.axId = 20
					b1.z_axis = c3.y_axis
					b1.y_axis.crosses = "max"
					b1 += c3

					c3.title = "High low close volume"

					ws.add_chart(b1, "A27")

					## Volume-open-high-low-close
					b2 = deepcopy(bar)
					c4 = deepcopy(c2)
					c4.y_axis.majorGridlines = None
					c4.y_axis.title = "Price"
					b2.y_axis.axId = 20
					b2.z_axis = c4.y_axis
					b2.y_axis.crosses = "max"
					b2 += c4

					ws.add_chart(b2, "G27")

					wb.save("stock.xlsx")
				J）Surface charts	曲面图
					工作表中的列或行中排列的数据可以绘制在曲面图中。当你想在两组数据之间找到最佳组合时，曲面图是有用的。如在地形图中，颜色和图案指示在相同的值范围内的区域。
					默认情况下，所有的表面图都是3D的。2D线框和轮廓图是通过设置旋转和透视来创建的。
						from openpyxl import Workbook
						from openpyxl.chart import (
							SurfaceChart,
							SurfaceChart3D,
							Reference,
							Series,
						)
						from openpyxl.chart.axis import SeriesAxis

						wb = Workbook()
						ws = wb.active

						data = [
							[None, 10, 20, 30, 40, 50,],
							[0.1, 15, 65, 105, 65, 15,],
							[0.2, 35, 105, 170, 105, 35,],
							[0.3, 55, 135, 215, 135, 55,],
							[0.4, 75, 155, 240, 155, 75,],
							[0.5, 80, 190, 245, 190, 80,],
							[0.6, 75, 155, 240, 155, 75,],
							[0.7, 55, 135, 215, 135, 55,],
							[0.8, 35, 105, 170, 105, 35,],
							[0.9, 15, 65, 105, 65, 15],
						]

						for row in data:
							ws.append(row)


						c1 = SurfaceChart()
						ref = Reference(ws, min_col=2, max_col=6, min_row=1, max_row=10)
						labels = Reference(ws, min_col=1, min_row=2, max_row=10)
						c1.add_data(ref, titles_from_data=True)
						c1.set_categories(labels)
						c1.title = "Contour"

						ws.add_chart(c1, "A12")

						from copy import deepcopy

						# wireframe
						c2 = deepcopy(c1)
						c2.wireframe = True
						c2.title = "2D Wireframe"

						ws.add_chart(c2, "G12")

						# 3D Surface
						c3 = SurfaceChart3D()
						c3.add_data(ref, titles_from_data=True)
						c3.set_categories(labels)
						c3.title = "Surface"

						ws.add_chart(c3, "A29")

						c4 = deepcopy(c3)
						c4.wireframe = True
						c4.title = "3D Wireframe"

						ws.add_chart(c4, "G29")

						wb.save("surface.xlsx")
			（2）创建图表
				图表由至少一个或多个数据点组成的系列构成，系列本身是单元格引用组成。
					>>> from openpyxl import Workbook
					>>> wb = Workbook()
					>>> ws = wb.active
					>>> for i in range(10):
					...     ws.append([i])
					>>>
					>>> from openpyxl.chart import BarChart, Reference, Series
					>>> values = Reference(ws, min_col=1, min_row=1, max_col=1, max_row=10)
					>>> chart = BarChart()
					>>> chart.add_data(values)
					>>> ws.add_chart(chart, "E15")
					>>> wb.save("SampleChart.xlsx")
				默认情况下，图表的左上角被锚定到单元格E15,图表大小为15*7.5厘米（大概是5列14行），可以通过设置图表的anchor、width和height属性来改变，实际尺寸依赖于操作系统和设备，其他锚点设置可以通过查看openpyxl.drawing.spreadsheet_drawing获取更多信息。
			（3）坐标轴
				A）Axis Limits and Scale	轴限和尺度
					A1）Minima and Maxima	最小值和最大值
						坐标轴最大最小值可以手工设定以在图表上显示特定范围。
							from openpyxl import Workbook
							from openpyxl.chart import (
								ScatterChart,
								Reference,
								Series,
							)

							wb = Workbook()
							ws = wb.active

							ws.append(['X', '1/X'])
							for x in range(-10, 11):
								if x:
									ws.append([x, 1.0 / x])

							chart1 = ScatterChart()
							chart1.title = "Full Axes"
							chart1.x_axis.title = 'x'
							chart1.y_axis.title = '1/x'
							chart1.legend = None

							chart2 = ScatterChart()
							chart2.title = "Clipped Axes"
							chart2.x_axis.title = 'x'
							chart2.y_axis.title = '1/x'
							chart2.legend = None

							# X轴最小值设置为0，最大值11，Y轴最小值0，最大值1.5
							chart2.x_axis.scaling.min = 0
							chart2.y_axis.scaling.min = 0
							chart2.x_axis.scaling.max = 11
							chart2.y_axis.scaling.max = 1.5

							x = Reference(ws, min_col=1, min_row=2, max_row=22)
							y = Reference(ws, min_col=2, min_row=2, max_row=22)
							s = Series(y, xvalues=x)
							chart1.append(s)
							chart2.append(s)

							ws.add_chart(chart1, "C1")
							ws.add_chart(chart2, "C15")

							wb.save("minmax.xlsx")
						在某些情况下，如所示的那样，设置轴限制实际上等效于显示数据的子范围。对于大型数据集，在使用Excel和OPEN/Libre Office中的数据子集而不是轴限制时，散点图的绘制（可能还有其他）将更快得多
					A2）Logarithmic Scaling	对数标度
						X轴和Y轴都可以对数缩放。对数的基可以设置为任何有效浮点。如果x轴按比例缩放，则该域中的负值将被丢弃。
							from openpyxl import Workbook
							from openpyxl.chart import (
								ScatterChart,
								Reference,
								Series,
							)
							import math

							wb = Workbook()
							ws = wb.active

							ws.append(['X', 'Gaussian'])
							for i, x in enumerate(range(-10, 11)):
								ws.append([x, "=EXP(-(($A${row}/6)^2))".format(row = i + 2)])

							chart1 = ScatterChart()
							chart1.title = "No Scaling"
							chart1.x_axis.title = 'x'
							chart1.y_axis.title = 'y'
							chart1.legend = None

							chart2 = ScatterChart()
							chart2.title = "X Log Scale"
							chart2.x_axis.title = 'x (log10)'
							chart2.y_axis.title = 'y'
							chart2.legend = None
							chart2.x_axis.scaling.logBase = 10

							chart3 = ScatterChart()
							chart3.title = "Y Log Scale"
							chart3.x_axis.title = 'x'
							chart3.y_axis.title = 'y (log10)'
							chart3.legend = None
							chart3.y_axis.scaling.logBase = 10

							chart4 = ScatterChart()
							chart4.title = "Both Log Scale"
							chart4.x_axis.title = 'x (log10)'
							chart4.y_axis.title = 'y (log10)'
							chart4.legend = None
							chart4.x_axis.scaling.logBase = 10
							chart4.y_axis.scaling.logBase = 10

							chart5 = ScatterChart()
							chart5.title = "Log Scale Base e"
							chart5.x_axis.title = 'x (ln)'
							chart5.y_axis.title = 'y (ln)'
							chart5.legend = None
							chart5.x_axis.scaling.logBase = math.e
							chart5.y_axis.scaling.logBase = math.e

							x = Reference(ws, min_col=1, min_row=2, max_row=22)
							y = Reference(ws, min_col=2, min_row=2, max_row=22)
							s = Series(y, xvalues=x)
							chart1.append(s)
							chart2.append(s)
							chart3.append(s)
							chart4.append(s)
							chart5.append(s)

							ws.add_chart(chart1, "C1")
							ws.add_chart(chart2, "I1")
							ws.add_chart(chart3, "C15")
							ws.add_chart(chart4, "I15")
							ws.add_chart(chart5, "F30")

							wb.save("log.xlsx")
					A3）Axis Orientation	轴取向
						轴可以正常显示，也可以反向显示。坐标轴取向由scaling的orientation属性决定，设为minMax时为正常显示，maxMin时反向显示。
							from openpyxl import Workbook
							from openpyxl.chart import (
								ScatterChart,
								Reference,
								Series,
							)

							wb = Workbook()
							ws = wb.active

							ws["A1"] = "Archimedean Spiral"
							ws.append(["T", "X", "Y"])
							for i, t in enumerate(range(100)):
								ws.append([t / 16.0, "=$A${row}*COS($A${row})".format(row = i + 3),
													 "=$A${row}*SIN($A${row})".format(row = i + 3)])

							chart1 = ScatterChart()
							chart1.title = "Default Orientation"
							chart1.x_axis.title = 'x'
							chart1.y_axis.title = 'y'
							chart1.legend = None

							chart2 = ScatterChart()
							chart2.title = "Flip X"
							chart2.x_axis.title = 'x'
							chart2.y_axis.title = 'y'
							chart2.legend = None
							chart2.x_axis.scaling.orientation = "maxMin"
							chart2.y_axis.scaling.orientation = "minMax"

							chart3 = ScatterChart()
							chart3.title = "Flip Y"
							chart3.x_axis.title = 'x'
							chart3.y_axis.title = 'y'
							chart3.legend = None
							chart3.x_axis.scaling.orientation = "minMax"
							chart3.y_axis.scaling.orientation = "maxMin"

							chart4 = ScatterChart()
							chart4.title = "Flip Both"
							chart4.x_axis.title = 'x'
							chart4.y_axis.title = 'y'
							chart4.legend = None
							chart4.x_axis.scaling.orientation = "maxMin"
							chart4.y_axis.scaling.orientation = "maxMin"

							x = Reference(ws, min_col=2, min_row=2, max_row=102)
							y = Reference(ws, min_col=3, min_row=2, max_row=102)
							s = Series(y, xvalues=x)
							chart1.append(s)
							chart2.append(s)
							chart3.append(s)
							chart4.append(s)

							ws.add_chart(chart1, "D1")
							ws.add_chart(chart2, "J1")
							ws.add_chart(chart3, "D15")
							ws.add_chart(chart4, "J15")

							wb.save("orientation.xlsx")
					B）Adding a second axis	添加第二坐标轴
						添加第二轴实际上涉及创建第二图表，该第二图表与第一图表共享共同的X轴，但具有单独的Y轴。
							from openpyxl import Workbook
							from openpyxl.chart import (
								LineChart,
								BarChart,
								Reference,
								Series,
							)

							wb = Workbook()
							ws = wb.active

							rows = [
								['Aliens', 2, 3, 4, 5, 6, 7],
								['Humans', 10, 40, 50, 20, 10, 50],
							]

							for row in rows:
								ws.append(row)

							c1 = BarChart()
							v1 = Reference(ws, min_col=1, min_row=1, max_col=7)
							c1.add_data(v1, titles_from_data=True, from_rows=True)

							c1.x_axis.title = 'Days'
							c1.y_axis.title = 'Aliens'
							c1.y_axis.majorGridlines = None
							c1.title = 'Survey results'


							# Create a second chart
							c2 = LineChart()
							v2 = Reference(ws, min_col=1, min_row=2, max_col=7)
							c2.add_data(v2, titles_from_data=True, from_rows=True)
							c2.y_axis.axId = 200
							c2.y_axis.title = "Humans"

							# Display y-axis of the second chart on the right by setting it to cross the x-axis at its maximum
							c1.y_axis.crosses = "max"
							c1 += c2

							ws.add_chart(c1, "D4")

							wb.save("secondary.xlsx")
				（4）Change the chart layout	改变图表布局
					A)改变绘图区和图例的布局
						画布内的图表布局可以使用布局属性作为布局类的实例来设置。
						A1）图表布局
							A11）尺寸和位置
								图表可以定位在其容器内，X和Y调整位置，W和H调整大小，单位是容器的比例，图表不能位于容器的外部，宽度和高度是主要的约束条件：如果x+w＞1，则x＝1—W。X是水平位置，从左边Y是垂直位置，顶部H是图表相对于容器的高度W是盒子的宽度。
							A12）模式
								除了大小和位置之外，相关属性的模式也可以设置为factor 或edge。factor是默认的。
									layout.xMode = edge
							A13）Target	目标
								布局目标可以被设置为outer或者inner,默认是outer。
									layout.layoutTarget = inner
						A2）Legend layout	图例布局
							图例的位置可以通过设置其位置：r、l、t、b和tr分别控制，分别为r、l、t、b和tr。默认为R
								legend.position = 'tr
							或者手动布局：
								legend.layout = ManualLayout()
								from openpyxl import Workbook, load_workbook
								from openpyxl.chart import ScatterChart, Series, Reference
								from openpyxl.chart.layout import Layout, ManualLayout

								wb = Workbook()
								ws = wb.active

								rows = [
									['Size', 'Batch 1', 'Batch 2'],
									[2, 40, 30],
									[3, 40, 25],
									[4, 50, 30],
									[5, 30, 25],
									[6, 25, 35],
									[7, 20, 40],
								]

								for row in rows:
									ws.append(row)

								ch1 = ScatterChart()
								xvalues = Reference(ws, min_col=1, min_row=2, max_row=7)
								for i in range(2, 4):
									values = Reference(ws, min_col=i, min_row=1, max_row=7)
									series = Series(values, xvalues, title_from_data=True)
									ch1.series.append(series)


								ch1.title = "Default layout"
								ch1.style = 13
								ch1.x_axis.title = 'Size'
								ch1.y_axis.title = 'Percentage'
								ch1.legend.position = 'r'

								ws.add_chart(ch1, "B10")

								from copy import deepcopy

								# Half-size chart, bottom right
								ch2 = deepcopy(ch1)
								ch2.title = "Manual chart layout"
								ch2.legend.position = "tr"
								ch2.layout=Layout(
									manualLayout=ManualLayout(
										x=0.25, y=0.25,
										h=0.5, w=0.5,
									)
								)
								ws.add_chart(ch2, "K10")

								# Half-size chart, centred
								ch3 = deepcopy(ch1)
								ch3.layout = Layout(
									ManualLayout(
									x=0.25, y=0.25,
									h=0.5, w=0.5,
									xMode="edge",
									yMode="edge",
									)
								)
								ch3.title = "Manual chart layout, edge mode"
								ws.add_chart(ch3, "B27")

								# Manually position the legend bottom left
								ch4 = deepcopy(ch1)
								ch4.title = "Manual legend layout"
								ch4.legend.layout = Layout(
									manualLayout=ManualLayout(
										yMode='edge',
										xMode='edge',
										x=0, y=0.9,
										h=0.1, w=0.5
									)
								)

								ws.add_chart(ch4, "K27")

								wb.save("chart_layout.xlsx")
						B)Styling charts	图表样式
							A31）Adding Patterns	添加样式
								整个数据序列和单个数据点可以通过图形属性被广泛地设计，把事情做得恰到好处可能需要一些时间。
									from openpyxl import Workbook
									from openpyxl.chart import BarChart, Reference
									from openpyxl.chart.marker import DataPoint

									from openpyxl.drawing.fill import PatternFillProperties, ColorChoice

									wb = Workbook()
									ws = wb.active

									rows = [
										("Sample",),
										(1,),
										(2,),
										(3,),
										(2,),
										(3,),
										(3,),
										(1,),
										(2,),
									]

									for r in rows:
										ws.append(r)


									c = BarChart()
									data = Reference(ws, min_col=1, min_row=1, max_row=8)
									c.add_data(data, titles_from_data=True)
									c.title = "Chart with patterns"

									# set a pattern for the whole series
									series = c.series[0]
									fill =  PatternFillProperties(prst="smConfetti")
									fill.foreground = ColorChoice(prstClr="green")
									fill.background = ColorChoice(prstClr="red")
									series.graphicalProperties.pattFill = fill

									# set a pattern for a 6th data point (0-indexed)
									pt = DataPoint(idx=5)
									pt.graphicalProperties.pattFill = PatternFillProperties(prst="ltHorz")
									series.dPt.append(pt)

									ws.add_chart(c, "C1")

									wb.save("pattern.xlsx")
						C）Advanced charts	高级图表
							Gauge Charts
								量表结合饼图和环形图来创建一个“量规”。第一张图是一张四片的甜甜圈图。前三片对应于量规的颜色；第四片是甜甜圈的一半，是不可见的。
								添加了包含三个切片的饼图。第一片和第三片是看不见的，因此第二片可以作为量规上的针。
								使用数据系列中的单个数据点的图形属性来完成效果。
									from openpyxl import Workbook

									from openpyxl.chart import PieChart, DoughnutChart, Series, Reference
									from openpyxl.chart.series import DataPoint


									data = [
										["Donut", "Pie"],
										[25, 75],
										[50, 1],
										[25, 124],
										[100],
									]

									# based on http://www.excel-easy.com/examples/gauge-chart.html

									wb = Workbook()
									ws = wb.active
									for row in data:
										ws.append(row)

									# First chart is a doughnut chart
									c1 = DoughnutChart(firstSliceAng=270, holeSize=50)
									c1.title = "Code coverage"
									c1.legend = None

									ref = Reference(ws, min_col=1, min_row=2, max_row=5)
									s1 = Series(ref, title_from_data=False)

									slices = [DataPoint(idx=i) for i in range(4)]
									slices[0].graphicalProperties.solidFill = "FF3300" # red
									slices[1].graphicalProperties.solidFill = "FCF305" # yellow
									slices[2].graphicalProperties.solidFill = "1FB714" # green
									slices[3].graphicalProperties.noFill = True # invisible

									s1.data_points = slices
									c1.series = [s1]

									# Second chart is a pie chart
									c2 = PieChart(firstSliceAng=270)
									c2.legend = None

									ref = Reference(ws, min_col=2, min_row=2, max_col=2, max_row=4)
									s2 = Series(ref, title_from_data=False)

									slices = [DataPoint(idx=i) for i in range(3)]
									slices[0].graphicalProperties.noFill = True # invisible
									slices[1].graphicalProperties.solidFill = "000000" # black needle
									slices[2].graphicalProperties.noFill = True # invisible
									s2.data_points = slices
									c2.series = [s2]

									c1 += c2 # combine charts

									ws.add_chart(c1, "D1")

									wb.save("gauge.xlsx")
						D）Using chartsheets	使用图表页
							图表是只包含图表的特殊工作表。图表的所有数据必须在不同的工作表上。
								from openpyxl import Workbook

								from openpyxl.chart import PieChart, Reference, Series

								wb = Workbook()
								ws = wb.active
								cs = wb.create_chartsheet()

								rows = [
									["Bob", 3],
									["Harry", 2],
									["James", 4],
								]

								for row in rows:
									ws.append(row)


								chart = PieChart()
								labels = Reference(ws, min_col=1, min_row=1, max_row=3)
								data = Reference(ws, min_col=2, min_row=1, max_row=3)
								chart.series = (Series(data),)
								chart.title = "PieChart"

								cs.add_chart(chart)

								wb.save("demo.xlsx")
		6.comments	评论
			Openpyxl目前只支持读和写评论文本。格式化信息丢失。评论维度在阅读时丢失，但可以被写入。如果使用read_only=True，则当前不支持注释。
				Adding a comment to a cell	向单元格添加注释
					评论有attribute和author属性，两个必须都进行设置。
					>>> from openpyxl import Workbook
					>>> from openpyxl.comments import Comment
					>>> wb = Workbook()
					>>> ws = wb.active
					>>> comment = ws["A1"].comment
					>>> comment = Comment('This is the comment text', 'Comment Author')
					>>> comment.text
					'This is the comment text'
					>>> comment.author
					'Comment Author'
			如果将相同的注释分配给多个单元格，openpyxl将自动创建副本。
				>>> from openpyxl import Workbook
				>>> from openpyxl.comments import Comment
				>>> from openpyxl.utils import units
				>>>
				>>> wb=Workbook()
				>>> ws=wb.active
				>>>
				>>> comment = Comment("Text", "Author")
				>>> comment.width = 300
				>>> comment.height = 50
				>>>
				>>> ws["A1"].comment = comment
				>>>
				>>> wb.save('commented_book.xlsx')
			如果需要的话，openpyxl.utils.units包含用于从其他测量单位转换为毫米或点到像素的辅助函数：
				>>> from openpyxl import Workbook
				>>> from openpyxl.comments import Comment
				>>> from openpyxl.utils import units
				>>>
				>>> wb=Workbook()
				>>> ws=wb.active
				>>>
				>>> comment = Comment("Text", "Author")
				>>> comment.width = units.points_to_pixels(300)
				>>> comment.height = units.points_to_pixels(50)
				>>>
				>>> ws["A1"].comment = comment
			加载和保存评论
				加载时工作簿中的注释自动存储在各自的单元的注释属性中。格式化信息如字体大小、粗体和斜体丢失，注释库容器的原始尺寸和位置也一样。
				保存时工作簿中剩余的注释将自动保存到工作簿文件中。
				注释维度只能指定为只读。注释维度以像素为单位。
		7.样式
			（1）介绍
				样式用来改变数据在屏幕上的显示效果，同样也可以觉定数字的形式。样式可以应用于以下几个方面：
					字体设置大小、颜色、下划线等
					填充设置图案或渐变
					设置单元格边框
					单元格对齐方式
					保护
				以下为默认设置:
					>>> from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font
					>>> font = Font(name='Calibri',
					...                 size=11,
					...                 bold=False,
					...                 italic=False,
					...                 vertAlign=None,
					...                 underline='none',
					...                 strike=False,
					...                 color='FF000000')
					>>> fill = PatternFill(fill_type=None,
					...                 start_color='FFFFFFFF',
					...                 end_color='FF000000')
					>>> border = Border(left=Side(border_style=None,
					...                           color='FF000000'),
					...                 right=Side(border_style=None,
					...                            color='FF000000'),
					...                 top=Side(border_style=None,
					...                          color='FF000000'),
					...                 bottom=Side(border_style=None,
					...                             color='FF000000'),
					...                 diagonal=Side(border_style=None,
					...                               color='FF000000'),
					...                 diagonal_direction=0,
					...                 outline=Side(border_style=None,
					...                              color='FF000000'),
					...                 vertical=Side(border_style=None,
					...                               color='FF000000'),
					...                 horizontal=Side(border_style=None,
					...                                color='FF000000')
					...                )
					>>> alignment=Alignment(horizontal='general',
					...                     vertical='bottom',
					...                     text_rotation=0,
					...                     wrap_text=False,
					...                     shrink_to_fit=False,
					...                     indent=0)
					>>> number_format = 'General'
					>>> protection = Protection(locked=True,
					...                         hidden=False)
					>>>
			（2）单元格样式和命名样式
				有两种样式类型：单元格类型和命名类型（同样也被成为类型模板）。
					A）单元格类型
						单元格类型一旦分配后，可以在对象之间进行分享，并且不能再改变，这有效避免了很多的副作用，比如：改变喝多单元格样式，而不是只改变一个。
							>>> from openpyxl.styles import colors
							>>> from openpyxl.styles import Font, Color
							>>> from openpyxl import Workbook
							>>> wb = Workbook()
							>>> ws = wb.active
							>>>
							>>> a1 = ws['A1']
							>>> d4 = ws['D4']
							>>> ft = Font(color=colors.RED)
							>>> a1.font = ft
							>>> d4.font = ft
							>>>
							>>> a1.font.italic = True # is not allowed 
							>>>
							>>> # If you want to change the color of a Font, you need to reassign it::
							>>>
							>>> a1.font = Font(color=colors.RED, italic=True) # the change only affects 
					B）复制样式
						样式也可以被复制
							>>> from openpyxl.styles import Font
							>>> from copy import copy
							>>>
							>>> ft1 = Font(name='Arial', size=14)
							>>> ft2 = copy(ft1)
							>>> ft2.name = "Tahoma"
							>>> ft1.name
							'Arial'
							>>> ft2.name
							'Tahoma'
							>>> ft2.size # copied from the
							14.0
					C）基本字体颜色
						颜色通常是RGB或ARGB。颜色模块包含一些方便的常量。
							>>> from openpyxl.styles import Font
							>>> from openpyxl.styles.colors import RED
							>>> font = Font(color=RED)
							>>> font = Font(color="FFBB00")
						还支持对传统索引颜色以及主题和色调的支持。
							>>> from openpyxl.styles.colors import Color
							>>> c = Color(indexed=32)
							>>> c = Color(theme=6, tint=0.5)
					D）应用样式
						样式直接应用于单元格。
							>>> from openpyxl.workbook import Workbook
							>>> from openpyxl.styles import Font, Fill
							>>> wb = Workbook()
							>>> ws = wb.active
							>>> c = ws['A1']
							>>> c.font = Font(size=12)
						样式也可以应用于列和行，但请注意，这仅适用于在文件关闭后创建的（在Excel中）的单元格。如果要将样式应用于整个行和列，则必须自己将样式应用于每个单元格。这是对文件格式的限制：
							>>> col = ws.column_dimensions['A']
							>>> col.font = Font(bold=True)
							>>> row = ws.row_dimensions[1]
							>>> row.font = Font(underline="single")
					E）合并单元格样式
						有时，您希望格式化单元格的范围，就好像它们是单个对象一样。Excel通过合并单元格（删除所有但左上角的单元格）来假装这是可能的，然后重新创建它们以应用伪样式。
						from openpyxl.styles import Border, Side, PatternFill, Font, GradientFill, Alignment
						from openpyxl import Workbook


						def style_range(ws, cell_range, border=Border(), fill=None, font=None, alignment=None):
							"""
							Apply styles to a range of cells as if they were a single cell.

							:param ws:  Excel worksheet instance
							:param range: An excel range to style (e.g. A1:F20)
							:param border: An openpyxl Border
							:param fill: An openpyxl PatternFill or GradientFill
							:param font: An openpyxl Font object
							"""

							top = Border(top=border.top)
							left = Border(left=border.left)
							right = Border(right=border.right)
							bottom = Border(bottom=border.bottom)

							first_cell = ws[cell_range.split(":")[0]]
							if alignment:
								ws.merge_cells(cell_range)
								first_cell.alignment = alignment

							rows = ws[cell_range]
							if font:
								first_cell.font = font

							for cell in rows[0]:
								cell.border = cell.border + top
							for cell in rows[-1]:
								cell.border = cell.border + bottom

							for row in rows:
								l = row[0]
								r = row[-1]
								l.border = l.border + left
								r.border = r.border + right
								if fill:
									for c in row:
										c.fill = fill

						wb = Workbook()
						ws = wb.active
						my_cell = ws['B2']
						my_cell.value = "My Cell"
						thin = Side(border_style="thin", color="000000")
						double = Side(border_style="double", color="ff0000")

						border = Border(top=double, left=thin, right=thin, bottom=double)
						fill = PatternFill("solid", fgColor="DDDDDD")
						fill = GradientFill(stop=("000000", "FFFFFF"))
						font = Font(b=True, color="FF0000")
						al = Alignment(horizontal="center", vertical="center")


						style_range(ws, 'B2:F4', border=border, fill=fill, font=font, alignment=al)
						wb.save("styled.xlsx")
					F）Edit Page Setup	页面设置
						>>> from openpyxl.workbook import Workbook
						>>>
						>>> wb = Workbook()
						>>> ws = wb.active
						>>>
						>>> ws.page_setup.orientation = ws.ORIENTATION_LANDSCAPE
						>>> ws.page_setup.paperSize = ws.PAPERSIZE_TABLOID
						>>> ws.page_setup.fitToHeight = 0
						>>> ws.page_setup.fitToWidth = 1
					G）Named Styles	命名样式
						与单元格Styles相反，命名样式是可变的。当您想同时将格式化应用到许多不同的单元格时，它们是有意义的。NB（附注）。一旦将命名样式分配给单元格，样式的附加更改就不会影响单元格。
						一旦命名样式已被注册到工作簿，就可以简单地通过名称来引用它。
						G1）创建命名样式
							>>> from openpyxl.styles import NamedStyle, Font, Border, Side
							>>> highlight = NamedStyle(name="highlight")
							>>> highlight.font = Font(bold=True, size=20)
							>>> bd = Side(style='thick', color="000000")
							>>> highlight.border = Border(left=bd, top=bd, right=bd, bottom=bd)
							一旦创建了命名样式，它就可以在工作簿中注册
							>>> ws['A1'].style = highlight
							但命名样式也将在第一次被分配给一个单元时自动注册：
							>>> ws['A1'].style = highlight
							一旦注册，只使用名称分配样式：
							>>> ws['D5'].style = 'highlight'
						G2）应用内置样式
							该规范包括一些内置样式，也可以使用。不幸的是，这些样式的名称存储在它们的本地化形式中。OpenPyxl将只识别英文名称，只与这里所写的完全一样。这些内容如下：
							‘Normal’ # same as no style
							Number formats
							‘Comma’
							‘Comma [0]’
							‘Currency’
							‘Currency [0]’
							‘Percent’
							Informative
							‘Calculation’
							‘Total’
							‘Note’
							‘Warning Text’
							‘Explanatory Text’
							Text styles
							‘Title’
							‘Headline 1’
							‘Headline 2’
							‘Headline 3’
							‘Headline 4’
							‘Hyperlink’
							‘Followed Hyperlink’
							‘Linked Cell’
							Comparisons
							‘Input’
							‘Output’
							‘Check Cell’
							‘Good’
							‘Bad’
							‘Neutral’
							Highlights
							‘Accent1’
							‘20 % - Accent1’
							‘40 % - Accent1’
							‘60 % - Accent1’
							‘Accent2’
							‘20 % - Accent2’
							‘40 % - Accent2’
							‘60 % - Accent2’
							‘Accent3’
							‘20 % - Accent3’
							‘40 % - Accent3’
							‘60 % - Accent3’
							‘Accent4’
							‘20 % - Accent4’
							‘40 % - Accent4’
							‘60 % - Accent4’
							‘Accent5’
							‘20 % - Accent5’
							‘40 % - Accent5’
							‘60 % - Accent5’
							‘Accent6’
							‘20 % - Accent6’
							‘40 % - Accent6’
							‘60 % - Accent6’
							‘Pandas’
		8.附加工作表属性
			这些是特定行为的高级属性，最常用的是“FitTopage”页面设置属性和定义工作表标签的背景颜色的tabColor。
			（1）可用的工作表属性
				“enableFormatConditionsCalculation”
				“filterMode”
				“published”
				“syncHorizontal”
				“syncRef”
				“syncVertical”
				“transitionEvaluation”
				“transitionEntry”
				“tabColor”
			（2）页面设置属性的可用字段		Available fields for page setup properties
				“autoPageBreaks” “fitToPage”
			（3）大纲可用字段	Available fields for outlines
				“applyStyles”
				“summaryBelow”
				“summaryRight”
				“showOutlineSymbols”
			更多内容参见： http://msdn.microsoft.com/en-us/library/documentformat.openxml.spreadsheet.sheetproperties%28v=office.14%29.aspx_
			默认情况下，大纲属性被初始化，这样您就可以直接修改它们的4个属性中的每一个，而页面设置属性则不会。如果要修改后者，则应该首先初始化openpyxl.worksheet.properties.PageSetupProperties 对象具有所需的参数。一旦完成，他们可以直接修改后的程序，如果需要的话。
				>>> from openpyxl.workbook import Workbook
				>>> from openpyxl.worksheet.properties import WorksheetProperties, PageSetupProperties
				>>>
				>>> wb = Workbook()
				>>> ws = wb.active
				>>>
				>>> wsprops = ws.sheet_properties
				>>> wsprops.tabColor = "1072BA"
				>>> wsprops.filterMode = False
				>>> wsprops.pageSetUpPr = PageSetupProperties(fitToPage=True, autoPageBreaks=False)
				>>> wsprops.outlinePr.summaryBelow = False
				>>> wsprops.outlinePr.applyStyles = True
				>>> wsprops.pageSetUpPr.autoPageBreaks = True
		9.条件格式
			Excel支持三种不同类型的条件格式化：内建、标准和自定义。内建将特定规则与预定义样式相结合。标准条件格式将特定规则与自定义格式化相结合。另外，可以使用自定义样式定义使用自定义样式的自定义公式。
			不同规则的语法变化很大，openpyxl不可能知道规则是否有意义。
			创建格式化规则的基本语法是：
				>>> from openpyxl.formatting import Rule
				>>> from openpyxl.styles import Font, PatternFill, Border
				>>> from openpyxl.styles.differential import DifferentialStyle
				>>> dxf = DifferentialStyle(font=Font(bold=True), fill=PatternFill(start_color='EE1111', end_color='EE1111'))
				>>> rule = Rule(type='cellIs', dxf=dxf, formula=["10"])
			因为某些规则的签名可以相当冗长，所以也有一些便利的工厂来创建它们。